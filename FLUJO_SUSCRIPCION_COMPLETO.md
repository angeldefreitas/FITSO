# Flujo Completo de Suscripci√≥n - Fitso MVP

Este documento explica paso a paso qu√© ocurre cuando un usuario selecciona un plan de suscripci√≥n y realiza una compra.

## üì± 1. FLUJO EN LA APP (React Native)

### 1.1. Usuario Selecciona un Plan
**Archivo:** `src/screens/PremiumScreen.tsx`

- El usuario ve dos opciones de planes:
  - **Monthly**: $2.99/mes
  - **Yearly**: $19.99/a√±o
- Selecciona uno de los planes (mensual o anual)
- Presiona el bot√≥n "Suscribirse ahora"

### 1.2. Inicio de la Compra
**Funci√≥n:** `handleSubscribe()` en `PremiumScreen.tsx`

```74:100:src/screens/PremiumScreen.tsx
  const handleSubscribe = async () => {
    try {
      // Usar los product IDs reales de RevenueCat
      // Estos deben coincidir con los productos configurados en RevenueCat dashboard
      const productId = selectedPlan === 'monthly' ? 'Fitso_Premium_Monthly' : 'Fitso_Premium_Yearly';
      console.log('üõí [PREMIUM SCREEN] Iniciando compra de:', productId);
      await purchaseSubscription(productId);
      console.log('‚úÖ [PREMIUM SCREEN] Compra completada exitosamente');
      
      // CR√çTICO: Esperar un momento adicional antes de cerrar para asegurar que el estado se actualice
      // El PremiumContext est√° haciendo m√∫ltiples intentos, pero necesitamos dar tiempo
      console.log('üîÑ [PREMIUM SCREEN] Esperando actualizaci√≥n del estado premium...');
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Forzar un √∫ltimo refresh del estado premium antes de cerrar
      console.log('üîÑ [PREMIUM SCREEN] Forzando √∫ltimo refresh del estado premium...');
      try {
        await refreshPremiumStatus();
        console.log('‚úÖ [PREMIUM SCREEN] Estado premium refrescado antes de cerrar');
      } catch (refreshError) {
        console.warn('‚ö†Ô∏è [PREMIUM SCREEN] Error refrescando estado premium:', refreshError);
        // Continuar con el cierre aunque haya error
      }
      
      // Cerrar la pantalla despu√©s de la compra exitosa
      console.log('‚úÖ [PREMIUM SCREEN] Cerrando pantalla - el estado premium deber√≠a estar actualizado');
      onClose();
    } catch (error) {
```

**Acciones:**
1. Determina el `productId` basado en el plan seleccionado:
   - `'Fitso_Premium_Monthly'` para plan mensual
   - `'Fitso_Premium_Yearly'` para plan anual
2. Llama a `purchaseSubscription(productId)` del `PremiumContext`

### 1.3. PremiumContext Procesa la Compra
**Archivo:** `src/contexts/PremiumContext.tsx`

```68:134:src/contexts/PremiumContext.tsx
  const purchaseSubscription = useCallback(async (productId: string) => {
    try {
      setLoading(true);
      console.log('üõí [PREMIUM CONTEXT] Iniciando compra de suscripci√≥n:', productId);
      
      await subscriptionService.purchaseSubscription(productId);
      
      // CR√çTICO: Forzar actualizaci√≥n completa del estado premium despu√©s de la compra
      console.log('üîÑ [PREMIUM CONTEXT] Forzando actualizaci√≥n completa del estado premium despu√©s de compra...');
      
      // M√∫ltiples intentos para asegurar que el estado se actualice
      let attempts = 0;
      const maxAttempts = 5;
      let freshStatus: PremiumStatus | null = null;
      
      while (attempts < maxAttempts) {
        attempts++;
        
        // Esperar con delay incremental: 0.5s, 1s, 1.5s, 2s, 2.5s
        if (attempts > 1) {
          const delay = (attempts - 1) * 500;
          console.log(`üîÑ [PREMIUM CONTEXT] Intento ${attempts}/${maxAttempts} - esperando ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
        
        // Forzar refresh desde RevenueCat
        try {
          await subscriptionService.refreshPremiumStatusFromRevenueCat();
          console.log('‚úÖ [PREMIUM CONTEXT] Estado refrescado desde RevenueCat');
        } catch (refreshError) {
          console.warn('‚ö†Ô∏è [PREMIUM CONTEXT] Error refrescando desde RevenueCat:', refreshError);
        }
        
        // Obtener estado fresco directamente desde RevenueCat
        freshStatus = await subscriptionService.getPremiumStatus();
        console.log(`üì¶ [PREMIUM CONTEXT] Intento ${attempts}/${maxAttempts} - Estado premium:`, freshStatus);
        
        // Si el estado premium est√° activo, salir del loop
        if (freshStatus.isPremium) {
          console.log('‚úÖ [PREMIUM CONTEXT] ¬°Estado premium detectado como activo!');
          break;
        } else {
          console.log(`‚ö†Ô∏è [PREMIUM CONTEXT] Estado premium a√∫n no activo en intento ${attempts}/${maxAttempts}`);
        }
      }
      
      // Actualizar estado del contexto con el √∫ltimo estado obtenido
      if (freshStatus) {
        setPremiumStatus(freshStatus);
        console.log('‚úÖ [PREMIUM CONTEXT] Estado premium actualizado en contexto:', freshStatus);
        
        if (!freshStatus.isPremium) {
          console.warn('‚ö†Ô∏è [PREMIUM CONTEXT] Estado premium NO activo despu√©s de', maxAttempts, 'intentos');
          console.warn('‚ö†Ô∏è [PREMIUM CONTEXT] El webhook puede tardar unos momentos m√°s en procesar');
          console.warn('‚ö†Ô∏è [PREMIUM CONTEXT] El estado se actualizar√° autom√°ticamente cuando el usuario vuelva a la app');
        }
      }
      
      console.log('‚úÖ [PREMIUM CONTEXT] Compra de suscripci√≥n completada y estado actualizado');
    } catch (error) {
      console.error('‚ùå [PREMIUM CONTEXT] Error en compra de suscripci√≥n:', error);
      // NO mostrar Alert.alert aqu√≠ - el error ser√° manejado por PremiumScreen con el modal bonito
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);
```

**Acciones:**
1. Llama a `subscriptionService.purchaseSubscription(productId)`
2. Realiza m√∫ltiples intentos (hasta 5) para verificar que el estado premium se actualice
3. Actualiza el estado del contexto con el nuevo estado premium

### 1.4. SubscriptionService Realiza la Compra
**Archivo:** `src/services/subscriptionService.ts`

**Pasos cr√≠ticos en `purchaseSubscription()`:**

1. **Configurar App User ID:**
   ```310:381:src/services/subscriptionService.ts
  async purchaseSubscription(productId: string): Promise<void> {
    try {
      if (!this.isInitialized) {
        try {
          await this.initialize();
        } catch (error) {
          throw new Error('RevenueCat no est√° disponible. Por favor, usa la versi√≥n nativa de la app para realizar compras.');
        }
      }

      // CR√çTICO: Configurar App User ID ANTES de la compra
      // Si no est√° configurado, RevenueCat usar√° un ID an√≥nimo y los webhooks no llegar√°n correctamente
      const userId = await this.getCurrentUserId();
      if (!userId) {
        throw new Error('Debes estar autenticado para realizar compras. Por favor, inicia sesi√≥n e intenta de nuevo.');
      }

      // CR√çTICO: Obtener el App User ID actual ANTES de configurarlo
      // Si hay un usuario diferente, hacer logout primero
      let currentCustomerInfo = await Purchases.getCustomerInfo();
      const currentAppUserId = currentCustomerInfo.originalAppUserId;
      
      console.log('üîç [PURCHASE] Estado ANTES de configurar App User ID:');
      console.log('  - Usuario esperado (de app):', userId);
      console.log('  - App User ID actual (RevenueCat):', currentAppUserId);
      
      // Si hay un usuario diferente configurado, cerrar sesi√≥n primero
      if (currentAppUserId && currentAppUserId !== userId) {
        console.warn('‚ö†Ô∏è [PURCHASE] CR√çTICO: Detectado usuario diferente en RevenueCat!');
        console.warn('  - Usuario anterior:', currentAppUserId);
        console.warn('  - Usuario nuevo:', userId);
        console.warn('üîÑ [PURCHASE] Cerrando sesi√≥n del usuario anterior para evitar mezclar compras...');
        
        await Purchases.logOut();
        console.log('‚úÖ [PURCHASE] Sesi√≥n anterior cerrada');
        
        // Esperar un momento para que RevenueCat procese el logout
        await new Promise(resolve => setTimeout(resolve, 500));
      }

      console.log('üë§ [PURCHASE] Configurando App User ID antes de la compra:', userId);
      await Purchases.logIn(userId);
      console.log('‚úÖ [PURCHASE] App User ID configurado');

      // Verificar que el App User ID se configur√≥ correctamente
      currentCustomerInfo = await Purchases.getCustomerInfo();
      const verifiedAppUserId = currentCustomerInfo.originalAppUserId;
      console.log('üë§ [PURCHASE] App User ID verificado en RevenueCat:', verifiedAppUserId);
      
      if (verifiedAppUserId !== userId) {
        console.error('‚ùå [PURCHASE] CR√çTICO: App User ID NO coincide despu√©s de configurar!');
        console.error('  - Esperado:', userId);
        console.error('  - Obtenido:', verifiedAppUserId);
        console.warn('‚ö†Ô∏è [PURCHASE] Intentando forzar actualizaci√≥n...');
        
        // Intentar de nuevo con logout/login
        await Purchases.logOut();
        await new Promise(resolve => setTimeout(resolve, 500));
        await Purchases.logIn(userId);
        
        const reVerifyInfo = await Purchases.getCustomerInfo();
        const reVerifiedAppUserId = reVerifyInfo.originalAppUserId;
        console.log('‚úÖ [PURCHASE] App User ID despu√©s de forzar:', reVerifiedAppUserId);
        
        if (reVerifiedAppUserId !== userId) {
          console.error('‚ùå [PURCHASE] CR√çTICO: App User ID A√öN no coincide despu√©s de forzar!');
          console.error('‚ùå [PURCHASE] La compra puede asociarse al usuario incorrecto!');
          // No lanzar error para permitir que la compra contin√∫e, pero registrar el problema
        }
      } else {
        console.log('‚úÖ [PURCHASE] App User ID verificado correctamente - la compra se asociar√° al usuario correcto');
      }
```

2. **Encontrar el paquete en RevenueCat:**
   ```429:503:src/services/subscriptionService.ts
      const packageToPurchase = offerings.current.availablePackages.find(
        pkg => {
          // Normalizar IDs para comparaci√≥n
          const packageIdLower = pkg.identifier.toLowerCase();
          const packageIdNoPrefix = packageIdLower.replace(/^\$rc_/, 'rc_');
          const productIdLower = productId.toLowerCase();
          const productIdNoPrefix = productIdLower.replace(/^\$rc_/, 'rc_');
          const pkgProductIdLower = pkg.product.identifier.toLowerCase();
          
          // 1. Comparaci√≥n exacta de package ID (si productId es un package ID)
          const exactPackageMatch = pkg.identifier === productId;
          
          // 2. Comparaci√≥n exacta de product ID (PRIMERA PRIORIDAD - m√°s confiable)
          const exactProductMatch = pkg.product.identifier === productId;
          
          // 3. Comparaci√≥n sin case sensitivity de product ID
          const caseInsensitiveProductMatch = pkgProductIdLower === productIdLower;
          
          // 4. Comparaci√≥n sin prefijo $ en package ID
          const noPrefixMatch = packageIdNoPrefix === productIdNoPrefix;
          
          // 5. Comparaci√≥n sin case sensitivity de package ID
          const caseInsensitivePackageMatch = packageIdLower === productIdLower;
          
          // 6. Match por contenido (monthly/annual/yearly) - √öTIL para sandbox vs producci√≥n
          // En sandbox, los productos pueden tener sufijo _Test, pero contienen "monthly" o "yearly"
          // Esto permite que Fitso_Premium_Monthly coincida con Fitso_Premium_Monthly_Test
          const productBaseMatch = 
            (productIdLower.includes('monthly') && pkgProductIdLower.includes('monthly')) ||
            ((productIdLower.includes('annual') || productIdLower.includes('yearly')) && 
             (pkgProductIdLower.includes('annual') || pkgProductIdLower.includes('yearly')));
          
          // Tambi√©n buscar por package ID si contiene el tipo
          const packageContentMatch = 
            (productIdLower.includes('monthly') && packageIdLower.includes('monthly')) ||
            ((productIdLower.includes('annual') || productIdLower.includes('yearly')) && 
             (packageIdLower.includes('annual') || packageIdLower.includes('yearly')));
          
          const contentMatch = productBaseMatch || packageContentMatch;
          
          // Priorizar matches exactos sobre matches por contenido
          const matches = exactProductMatch || exactPackageMatch || caseInsensitiveProductMatch || 
                         caseInsensitivePackageMatch || noPrefixMatch || contentMatch;
          
          if (matches) {
            console.log(`‚úÖ [PURCHASE] Match encontrado:`);
            console.log(`   Package ID: ${pkg.identifier}`);
            console.log(`   Product ID: ${pkg.product.identifier}`);
            console.log(`   Product Title: ${pkg.product.title}`);
            console.log(`   Match type: ${exactProductMatch ? 'exact product' : 
                         exactPackageMatch ? 'exact package' :
                         caseInsensitiveProductMatch ? 'case-insensitive product' :
                         caseInsensitivePackageMatch ? 'case-insensitive package' :
                         noPrefixMatch ? 'no prefix' : 'content'}`);
          }
          
          return matches;
        }
      );

      if (!packageToPurchase) {
        console.error('‚ùå [PURCHASE] Paquete no encontrado en RevenueCat');
        console.error('‚ùå [PURCHASE] ProductId buscado:', productId);
        console.error('‚ùå [PURCHASE] Paquetes disponibles:', offerings.current.availablePackages.map(p => ({ 
          packageId: p.identifier, 
          productId: p.product.identifier,
          productTitle: p.product.title
        })));
        console.error('‚ùå [PURCHASE] Esto puede deberse a:');
        console.error('   1. El package ID no coincide con los configurados en RevenueCat');
        console.error('   2. Los productos no est√°n correctamente vinculados en RevenueCat');
        console.error('   3. El productId usado es incorrecto');
        throw new Error('No pudimos encontrar el producto. Por favor, verifica tu conexi√≥n e int√©ntalo de nuevo.');
      }
      console.log('‚úÖ [PURCHASE] Paquete encontrado:', packageToPurchase.identifier);
```

3. **Realizar la compra con RevenueCat:**
   ```505:593:src/services/subscriptionService.ts
      // Realizar la compra
      console.log('üí≥ [PURCHASE] Iniciando compra con RevenueCat...');
      const { customerInfo: purchaseCustomerInfo } = await Purchases.purchasePackage(packageToPurchase);
      
      console.log('üì¶ [PURCHASE] Customer Info despu√©s de compra:');
      console.log('  - App User ID:', purchaseCustomerInfo.originalAppUserId);
      console.log('  - Active Subscriptions:', purchaseCustomerInfo.activeSubscriptions);
      console.log('  - All Entitlements:', Object.keys(purchaseCustomerInfo.entitlements.all || {}));
      console.log('  - Active Entitlements:', Object.keys(purchaseCustomerInfo.entitlements.active || {}));
      console.log('  - Buscando entitlement:', PREMIUM_ENTITLEMENT);
      
      // CR√çTICO: Verificar que el App User ID sigue siendo el correcto despu√©s de la compra
      if (purchaseCustomerInfo.originalAppUserId !== userId) {
        console.error('‚ùå [PURCHASE] CR√çTICO: App User ID cambi√≥ despu√©s de la compra!');
        console.error('  - Usuario esperado (de app):', userId);
        console.error('  - App User ID despu√©s de compra:', purchaseCustomerInfo.originalAppUserId);
        console.error('  - ‚ö†Ô∏è ESTO ES GRAVE: La compra puede asociarse al usuario incorrecto en RevenueCat!');
        console.error('  - ‚ö†Ô∏è Esto explica por qu√© solo ves un evento en RevenueCat dashboard');
        console.error('  - ‚ö†Ô∏è Todas las compras pueden estar asoci√°ndose al mismo usuario');
        
        // Intentar corregir el App User ID despu√©s de la compra
        console.warn('üîÑ [PURCHASE] Intentando corregir App User ID despu√©s de la compra...');
        try {
          await Purchases.logIn(userId);
          const correctedInfo = await Purchases.getCustomerInfo();
          console.log('‚úÖ [PURCHASE] App User ID corregido:', correctedInfo.originalAppUserId);
        } catch (correctError) {
          console.error('‚ùå [PURCHASE] No se pudo corregir App User ID:', correctError);
        }
      } else {
        console.log('‚úÖ [PURCHASE] App User ID verificado correctamente despu√©s de la compra');
        console.log('‚úÖ [PURCHASE] La compra se asociar√° al usuario correcto en RevenueCat');
      }
      
      // Obtener customerInfo fresco despu√©s de la compra para asegurar que est√© sincronizado
      console.log('üîÑ [PURCHASE] Obteniendo Customer Info fresco desde RevenueCat...');
      let finalCustomerInfo = purchaseCustomerInfo;
      try {
        // Esperar un momento para que RevenueCat procese la compra
        await new Promise(resolve => setTimeout(resolve, 500));
        finalCustomerInfo = await Purchases.getCustomerInfo();
        console.log('‚úÖ [PURCHASE] Customer Info actualizado obtenido');
      } catch (error) {
        console.warn('‚ö†Ô∏è [PURCHASE] No se pudo obtener Customer Info fresco, usando el de la compra:', error);
      }
      
      // Verificar si el usuario tiene acceso premium
      // IMPORTANTE: A veces RevenueCat tarda unos segundos en activar el entitlement
      // Intentar varias veces con delays incrementales
      let premiumEntitlement = finalCustomerInfo.entitlements.active[PREMIUM_ENTITLEMENT];
      let attempts = 0;
      const maxAttempts = 3;
      
      while (!premiumEntitlement && attempts < maxAttempts) {
        if (attempts > 0) {
          console.log(`üîÑ [PURCHASE] Intentando verificar entitlement (intento ${attempts + 1}/${maxAttempts})...`);
          // Esperar con delay incremental: 1s, 2s, 3s
          await new Promise(resolve => setTimeout(resolve, attempts * 1000));
          finalCustomerInfo = await Purchases.getCustomerInfo();
        }
        
        premiumEntitlement = finalCustomerInfo.entitlements.active[PREMIUM_ENTITLEMENT];
        attempts++;
        
        if (premiumEntitlement) {
          console.log(`‚úÖ [PURCHASE] Entitlement encontrado despu√©s de ${attempts} intento(s)`);
          break;
        }
      }
      
      if (premiumEntitlement) {
        console.log('‚úÖ [PURCHASE] Compra exitosa, usuario tiene acceso premium');
        console.log('üì¶ [PURCHASE] Premium entitlement activo:');
        console.log('  - Identifier:', premiumEntitlement.identifier);
        console.log('  - Expiration Date:', premiumEntitlement.expirationDate);
        console.log('  - Is Active:', premiumEntitlement.isActive);
        console.log('  - Product Identifier:', premiumEntitlement.productIdentifier);
        
        // Actualizar estado premium desde RevenueCat inmediatamente
        await this.refreshPremiumStatusFromRevenueCat();
        
        // Forzar otra actualizaci√≥n despu√©s de un peque√±o delay para asegurar que se sincroniza
        setTimeout(async () => {
          console.log('üîÑ [PURCHASE] Re-verificando estado premium despu√©s de compra...');
          await this.refreshPremiumStatusFromRevenueCat();
        }, 2000);
        
        // Notificar al backend sobre la compra (para comisiones de afiliados)
        await this.notifyBackendAboutPurchase(productId, finalCustomerInfo);
```

4. **Notificar al backend (opcional):**
   ```1142:1213:src/services/subscriptionService.ts
  private async notifyBackendAboutPurchase(productId: string, customerInfo: CustomerInfo): Promise<void> {
    try {
      console.log('üì§ [SUBSCRIPTION] Notificando al backend sobre la compra...');
      
      const { default: apiService } = await import('./apiService');
      const userId = await this.getCurrentUserId();
      
      // Extraer informaci√≥n de la compra
      const premiumEntitlement = customerInfo.entitlements.active[PREMIUM_ENTITLEMENT];
      
      // Determinar el tipo de suscripci√≥n basado en productId o package identifier
      let subscriptionType = 'monthly';
      if (productId.includes('Monthly') || productId.includes('monthly') || 
          productId === '$rc_monthly' || productId === 'rc_monthly') {
        subscriptionType = 'monthly';
      } else if (productId.includes('Yearly') || productId.includes('yearly') || 
                 productId.includes('Annual') || productId.includes('annual') ||
                 productId === '$rc_annual' || productId === 'rc_annual') {
        subscriptionType = 'yearly';
      }
      
      // Obtener el ID de la transacci√≥n m√°s reciente
      // RevenueCat proporciona latestPurchaseDate, pero necesitamos un ID √∫nico
      // Usar el latestTransactionDate del entitlement o generar uno basado en la fecha
      const transactionId = premiumEntitlement?.latestPurchaseDate ? 
        `rc_${Date.parse(premiumEntitlement.latestPurchaseDate)}` : 
        `rc_${Date.now()}`;
      
      // Calcular precio basado en el plan
      const price = subscriptionType === 'monthly' ? 2.99 : 19.99;
      
      const purchaseData = {
        userId,
        productId,
        subscriptionType,
        transactionId,
        purchaseDate: new Date().toISOString(),
        expiresAt: premiumEntitlement?.expirationDate,
        price,
      };
      
      console.log('üìä [SUBSCRIPTION] Datos de compra:', purchaseData);
      
      // Enviar al backend
      try {
        const response = await apiService.post('/subscriptions/purchase', purchaseData);
        
        if (response.success) {
          console.log('‚úÖ [SUBSCRIPTION] Backend notificado exitosamente');
          console.log('üí∞ [SUBSCRIPTION] Comisi√≥n de afiliado procesada:', response.data);
        } else {
          console.warn('‚ö†Ô∏è [SUBSCRIPTION] Backend respondi√≥ con error:', response.message);
          console.warn('‚ÑπÔ∏è [SUBSCRIPTION] La comisi√≥n ser√° procesada por el webhook de RevenueCat');
        }
      } catch (apiError: any) {
        // El 404 u otros errores del backend no deben afectar el flujo de compra
        // El webhook de RevenueCat se encargar√° de procesar la comisi√≥n
        if (apiError?.message?.includes('404') || apiError?.message?.includes('not found')) {
          console.warn('‚ö†Ô∏è [SUBSCRIPTION] Endpoint no encontrado (404) - esto puede ser normal si el backend est√° en mantenimiento');
        } else {
          console.error('‚ùå [SUBSCRIPTION] Error notificando al backend:', apiError?.message || apiError);
        }
        console.log('‚ÑπÔ∏è [SUBSCRIPTION] La compra se complet√≥ exitosamente. La comisi√≥n ser√° procesada por el webhook de RevenueCat.');
      }
      
    } catch (error) {
      console.error('‚ùå [SUBSCRIPTION] Error inesperado notificando al backend:', error);
      // No lanzar error para no afectar el flujo de compra
      // El webhook de RevenueCat se encargar√° de procesar la comisi√≥n
      console.log('‚ÑπÔ∏è [SUBSCRIPTION] La comisi√≥n ser√° procesada por el webhook de RevenueCat');
    }
  }
```

**Resumen del flujo en la app:**
- ‚úÖ Configura App User ID en RevenueCat
- ‚úÖ Busca el paquete/producto en RevenueCat
- ‚úÖ Realiza la compra usando `Purchases.purchasePackage()`
- ‚úÖ Verifica que el entitlement premium est√© activo
- ‚úÖ Actualiza el estado premium localmente
- ‚úÖ (Opcional) Notifica al backend sobre la compra

---

## üåê 2. FLUJO EN REVENUECAT

### 2.1. Procesamiento de la Compra
Cuando RevenueCat recibe la solicitud de compra desde la app:

1. **Valida la compra con Apple/Google:**
   - Verifica que el producto existe en App Store/Play Store
   - Valida que el usuario puede realizar la compra
   - Procesa el pago con Apple/Google

2. **Activa el entitlement:**
   - Asigna el entitlement `'entl0b12b2e363'` (Fitso Premium) al usuario
   - Marca la suscripci√≥n como activa
   - Almacena informaci√≥n de la transacci√≥n

3. **Env√≠a webhook al backend:**
   - Genera un evento de tipo `INITIAL_PURCHASE` (primera compra)
   - Env√≠a POST request a: `https://[TU_DOMINIO_RENDER]/api/webhooks/revenuecat`
   - El payload incluye:
     - `event.type`: Tipo de evento (INITIAL_PURCHASE, RENEWAL, etc.)
     - `event.app_user_id`: ID del usuario (debe coincidir con el userId de la BD)
     - `event.product_id`: ID del producto comprado
     - `event.price`: Precio de la compra
     - `event.id`: ID de la transacci√≥n

---

## üñ•Ô∏è 3. FLUJO EN RENDER (Backend)

### 3.1. Recepci√≥n del Webhook
**Archivo:** `backend/src/server.js`

El servidor recibe el webhook en el endpoint `/api/webhooks/revenuecat` (configurado en `backend/src/routes/webhooks.js`).

### 3.2. Procesamiento del Webhook
**Archivo:** `backend/src/monetization/controllers/revenuecatWebhookController.js`

```9:154:backend/src/monetization/controllers/revenuecatWebhookController.js
  async handleWebhook(req, res) {
    try {
      // Validar secreto de RevenueCat para seguridad
      const webhookSecret = process.env.REVENUECAT_WEBHOOK_SECRET;
      const authHeader = req.headers['authorization'] || req.headers['Authorization'];
      
      // Logging para debugging
      console.log('üîç [REVENUECAT] Validando webhook...');
      console.log('üîë [REVENUECAT] Webhook secret configurado:', webhookSecret ? 'S√≠' : 'No');
      console.log('üì® [REVENUECAT] Authorization header recibido:', authHeader ? `${authHeader.substring(0, 20)}...` : 'No presente');
      
      if (webhookSecret && authHeader) {
        // Normalizar el header (quitar espacios extras, manejar may√∫sculas/min√∫sculas)
        const normalizedHeader = authHeader.trim();
        const expectedAuth = `Bearer ${webhookSecret}`;
        
        // Comparar de forma flexible (sin importar may√∫sculas/min√∫sculas en "Bearer")
        const headerParts = normalizedHeader.split(' ');
        const receivedSecret = headerParts.length > 1 ? headerParts.slice(1).join(' ') : normalizedHeader;
        
        // Comparar el secret (la parte despu√©s de "Bearer")
        if (receivedSecret.trim() !== webhookSecret.trim()) {
          console.error('‚ùå [REVENUECAT] Authorization inv√°lida');
          console.error('‚ùå [REVENUECAT] Esperado:', `Bearer ${webhookSecret.substring(0, 10)}...`);
          console.error('‚ùå [REVENUECAT] Recibido:', `${authHeader.substring(0, 30)}...`);
          
          // IMPORTANTE: En desarrollo/sandbox, permitir continuar para debugging
          // En producci√≥n, deber√≠a rechazar
          const isDevelopment = process.env.NODE_ENV !== 'production';
          if (isDevelopment) {
            console.warn('‚ö†Ô∏è [REVENUECAT] Modo desarrollo: continuando sin validaci√≥n estricta');
          } else {
            return res.status(401).json({
              success: false,
              message: 'Unauthorized'
            });
          }
        } else {
          console.log('‚úÖ [REVENUECAT] Authorization v√°lida');
        }
      } else if (webhookSecret && !authHeader) {
        console.warn('‚ö†Ô∏è [REVENUECAT] Webhook secret configurado pero no se recibi√≥ header Authorization');
        console.warn('‚ö†Ô∏è [REVENUECAT] Continuando sin validaci√≥n (modo permisivo para testing)');
      }

      const payload = req.body;
      
      console.log('üì® [REVENUECAT] Webhook recibido');
      console.log('üìã [REVENUECAT] Payload:', JSON.stringify(payload, null, 2));

      // Validar que el evento tenga la estructura correcta
      if (!payload || !payload.event) {
        console.error('‚ùå [REVENUECAT] Payload inv√°lido:', payload);
        return res.status(400).json({
          success: false,
          message: 'Payload inv√°lido'
        });
      }

      // Extraer informaci√≥n del evento
      const eventData = payload.event;
      const eventType = eventData.type;
      
      // Informaci√≥n del usuario y suscripci√≥n
      const appUserId = eventData.app_user_id;
      const productId = eventData.product_id;
      const transactionId = eventData.id;
      const price = eventData.price || eventData.price_in_purchased_currency || 0;
      const currency = eventData.currency || 'USD';

      console.log(`üì® [REVENUECAT] Tipo de evento: ${eventType}`);
      console.log(`üë§ [REVENUECAT] Usuario: ${appUserId}`);
      console.log(`üì¶ [REVENUECAT] Producto: ${productId}`);
      console.log(`üí∞ [REVENUECAT] Precio: ${price} ${currency}`);

      // Procesar seg√∫n el tipo de evento
      switch (eventType) {
        case 'TEST':
          console.log('‚úÖ [REVENUECAT] Evento de prueba recibido correctamente');
          console.log('‚ÑπÔ∏è [REVENUECAT] Los eventos TEST son de RevenueCat para verificar que el webhook funciona');
          console.log('‚ÑπÔ∏è [REVENUECAT] Este NO es un evento de compra real - no se procesar√°');
          break;

        case 'INITIAL_PURCHASE':
          console.log('üéâ [REVENUECAT] Compra inicial detectada - procesando...');
          await this.handleInitialPurchase(appUserId, transactionId, price, productId);
          break;
        
        case 'RENEWAL':
          await this.handleRenewal(appUserId, transactionId, price, productId);
          break;
        
        case 'CANCELLATION':
          await this.handleCancellation(appUserId, transactionId);
          break;
        
        case 'EXPIRATION':
          await this.handleExpiration(appUserId, transactionId);
          break;
        
        case 'BILLING_ISSUE':
          await this.handleBillingIssue(appUserId, transactionId);
          break;
        
        case 'NON_RENEWING_PURCHASE':
          console.log('‚ÑπÔ∏è [REVENUECAT] Compra no renovable, no se genera comisi√≥n recurrente');
          break;
        
        case 'DID_CHANGE_RENEWAL_PREF':
          // Este evento ocurre cuando el usuario cambia su preferencia de renovaci√≥n (ej: mensual a anual)
          // Aunque no es una compra inicial, puede indicar un upgrade/downgrade
          console.log('üîÑ [REVENUECAT] Cambio de preferencia de renovaci√≥n detectado');
          console.log('‚ÑπÔ∏è [REVENUECAT] Este evento indica cambio de plan, pero no es una compra inicial');
          console.log('‚ÑπÔ∏è [REVENUECAT] Si hay app_user_id y product_id, verificaremos si es necesario procesar');
          
          // Si tenemos app_user_id y product_id, podr√≠amos procesarlo como un cambio de suscripci√≥n
          // Por ahora solo logueamos, pero podr√≠amos expandir esto si es necesario
          if (appUserId && productId) {
            console.log(`‚ÑπÔ∏è [REVENUECAT] Usuario ${appUserId} cambi√≥ a producto ${productId}`);
            // Nota: Este evento normalmente NO requiere procesar comisiones porque no es una conversi√≥n inicial
            // Pero si el usuario hizo un upgrade/downgrade, podr√≠a requerir l√≥gica adicional
          }
          break;
        
        default:
          console.log(`‚ö†Ô∏è [REVENUECAT] Evento no manejado: ${eventType}`);
          console.log(`‚ö†Ô∏è [REVENUECAT] App User ID: ${appUserId || 'NO DISPONIBLE'}`);
          console.log(`‚ö†Ô∏è [REVENUECAT] Product ID: ${productId || 'NO DISPONIBLE'}`);
      }

      // Responder siempre con 200 para que RevenueCat no reintente
      res.status(200).json({
        success: true,
        message: 'Webhook procesado'
      });

    } catch (error) {
      console.error('‚ùå [REVENUECAT] Error procesando webhook:', error);
      
      // A√∫n as√≠ responder con 200 para evitar reintentos innecesarios
      res.status(200).json({
        success: false,
        message: 'Error procesado internamente'
      });
    }
  }
```

### 3.3. Manejo de Compra Inicial
**Archivo:** `backend/src/monetization/controllers/revenuecatWebhookController.js`

```156:210:backend/src/monetization/controllers/revenuecatWebhookController.js
  async handleInitialPurchase(appUserId, transactionId, price, productId) {
    try {
      console.log('üéâ [REVENUECAT] Primera compra detectada');
      console.log('üë§ [REVENUECAT] App User ID:', appUserId);
      console.log('üì¶ [REVENUECAT] Product ID:', productId);
      console.log('üí∞ [REVENUECAT] Price:', price);
      
      // IMPORTANTE: El appUserId que viene de RevenueCat es el ID del usuario en nuestra BD
      // Buscar el usuario por su ID (que deber√≠a coincidir con el app_user_id configurado)
      const userQuery = 'SELECT id, email, name FROM users WHERE id = $1';
      const userResult = await query(userQuery, [appUserId]);
      
      if (userResult.rows.length === 0) {
        console.error('‚ùå [REVENUECAT] Usuario no encontrado en BD con App User ID:', appUserId);
        console.log('‚ÑπÔ∏è [REVENUECAT] Esto puede ocurrir si el App User ID no coincide con el ID del usuario en la BD');
        console.log('‚ÑπÔ∏è [REVENUECAT] El webhook se procesar√° pero no se actualizar√° el usuario');
        return;
      }
      
      const user = userResult.rows[0];
      console.log('‚úÖ [REVENUECAT] Usuario encontrado:', user.email, user.name);
      
      // Determinar tipo de suscripci√≥n
      const subscriptionType = productId.toLowerCase().includes('monthly') ? 'monthly' : 'yearly';
      
      // Procesar comisi√≥n de conversi√≥n
      const commission = await AffiliateService.processPremiumConversion(
        appUserId,
        transactionId,
        price,
        subscriptionType
      );

      if (commission) {
        console.log(`‚úÖ [REVENUECAT] Comisi√≥n inicial generada: $${commission.commission_amount}`);
      } else {
        console.log('‚ÑπÔ∏è [REVENUECAT] Usuario sin c√≥digo de referencia o c√≥digo inv√°lido');
      }
      
      // El estado premium se maneja autom√°ticamente por:
      // 1. RevenueCat SDK en la app (actualiza el estado local)
      // 2. La tabla subscriptions (si existe una suscripci√≥n activa, el usuario es premium)
      // 3. is_affiliate o is_admin en users (otorgan premium autom√°tico)
      
      console.log('‚úÖ [REVENUECAT] Compra inicial procesada correctamente');
      console.log('‚ÑπÔ∏è [REVENUECAT] El estado premium se actualizar√° autom√°ticamente en la app cuando verifique con RevenueCat');

    } catch (error) {
      console.error('‚ùå [REVENUECAT] Error en handleInitialPurchase:', error);
      throw error;
    }
  }
```

**Acciones en el backend:**
1. Valida el webhook (verifica el secret)
2. Extrae informaci√≥n del evento (`app_user_id`, `product_id`, `price`, etc.)
3. Busca el usuario en la base de datos usando el `app_user_id`
4. Determina el tipo de suscripci√≥n (monthly/yearly)
5. Procesa comisi√≥n de afiliado (si el usuario tiene c√≥digo de referencia)

### 3.4. Procesamiento de Comisi√≥n de Afiliado
**Archivo:** `backend/src/monetization/services/affiliateService.js`

Cuando el usuario tiene un c√≥digo de referencia, el sistema:
1. Busca la referencia del usuario en `user_referrals`
2. Obtiene informaci√≥n del c√≥digo de afiliado
3. Calcula la comisi√≥n seg√∫n el porcentaje configurado
4. Crea un registro en `affiliate_commissions`

---

## üìä RESUMEN DEL FLUJO COMPLETO

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      FLUJO DE SUSCRIPCI√ìN                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. APP (PremiumScreen.tsx)
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Usuario selecciona plan (monthly/yearly)
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Llama purchaseSubscription(productId)
   ‚îÇ
   ‚îî‚îÄ‚ñ∫ PremiumContext procesa la compra
       ‚îÇ
       ‚îî‚îÄ‚ñ∫ SubscriptionService.purchaseSubscription()
           ‚îÇ
           ‚îú‚îÄ‚ñ∫ Configura App User ID en RevenueCat
           ‚îú‚îÄ‚ñ∫ Busca el paquete/producto
           ‚îú‚îÄ‚ñ∫ Realiza compra: Purchases.purchasePackage()
           ‚îú‚îÄ‚ñ∫ Verifica entitlement premium activo
           ‚îú‚îÄ‚ñ∫ Actualiza estado premium local
           ‚îî‚îÄ‚ñ∫ (Opcional) Notifica backend v√≠a POST /subscriptions/purchase

2. REVENUECAT
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Valida compra con Apple/Google
   ‚îú‚îÄ‚ñ∫ Procesa el pago
   ‚îú‚îÄ‚ñ∫ Activa entitlement premium
   ‚îî‚îÄ‚ñ∫ Env√≠a webhook al backend:
       ‚îÇ
       ‚îî‚îÄ‚ñ∫ POST https://[RENDER]/api/webhooks/revenuecat
           ‚îÇ
           ‚îî‚îÄ‚ñ∫ Evento: INITIAL_PURCHASE (o RENEWAL)

3. BACKEND (Render)
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Recibe webhook en /api/webhooks/revenuecat
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Valida autenticaci√≥n (webhook secret)
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Extrae datos del evento:
   ‚îÇ   ‚îú‚îÄ app_user_id
   ‚îÇ   ‚îú‚îÄ product_id
   ‚îÇ   ‚îú‚îÄ price
   ‚îÇ   ‚îî‚îÄ transaction_id
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Busca usuario en BD
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Procesa comisi√≥n de afiliado (si aplica):
   ‚îÇ   ‚îú‚îÄ Busca c√≥digo de referencia del usuario
   ‚îÇ   ‚îú‚îÄ Calcula comisi√≥n
   ‚îÇ   ‚îî‚îÄ Crea registro en affiliate_commissions
   ‚îÇ
   ‚îî‚îÄ‚ñ∫ Responde 200 OK a RevenueCat

4. APP (Actualizaci√≥n del Estado)
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ SubscriptionService verifica estado premium
   ‚îú‚îÄ‚ñ∫ Actualiza PremiumContext
   ‚îî‚îÄ‚ñ∫ Usuario ve estado premium activo
```

---

## ‚ö†Ô∏è PUNTOS CR√çTICOS

### 1. App User ID - M√∫ltiples Usuarios
**IMPORTANTE:** No hay un solo `app_user_id`. Cada usuario tiene su propio `app_user_id` √∫nico.

**C√≥mo funciona:**

1. **Cada usuario tiene su propio `app_user_id`:**
   - El `app_user_id` = `user.id` (ID del usuario en la base de datos)
   - Ejemplo: Usuario A con `id: "123"` ‚Üí `app_user_id: "123"`
   - Ejemplo: Usuario B con `id: "456"` ‚Üí `app_user_id: "456"`

2. **Configuraci√≥n cuando un usuario se autentica:**
   ```typescript
   // En PremiumContext.tsx
   await subscriptionService.setAppUserId(user.id); // Configura el app_user_id del usuario actual
   ```

3. **Cambio de usuario (logout/login):**
   ```typescript
   // En AuthContext.tsx - cuando un usuario hace logout
   await Purchases.logOut(); // Cierra sesi√≥n del usuario anterior
   
   // Cuando un nuevo usuario se autentica
   await Purchases.logIn(newUser.id); // Configura el app_user_id del nuevo usuario
   ```

4. **Detecci√≥n de cambio de usuario:**
   ```typescript
   // El c√≥digo verifica si hay un usuario diferente configurado
   const currentAppUserId = currentCustomerInfo.originalAppUserId;
   if (currentAppUserId && currentAppUserId !== user.id) {
     // Hay un usuario diferente ‚Üí hacer logout primero
     await Purchases.logOut();
     // Luego configurar el nuevo usuario
     await Purchases.logIn(user.id);
   }
   ```

**CR√çTICO:** 
- El `app_user_id` configurado en RevenueCat debe coincidir exactamente con el `id` del usuario en la base de datos
- Si no coincide, el webhook no podr√° encontrar al usuario y no se procesar√° la comisi√≥n
- Cada usuario debe tener su propio `app_user_id` configurado ANTES de hacer cualquier compra

### 2. Endpoint del Webhook
- **URL:** `https://[TU_DOMINIO_RENDER]/api/webhooks/revenuecat`
- Debe estar configurado en el dashboard de RevenueCat
- Debe ser accesible p√∫blicamente

### 3. Webhook Secret
- Debe estar configurado en:
  - **RevenueCat Dashboard:** Configuraci√≥n del webhook
  - **Render:** Variable de entorno `REVENUECAT_WEBHOOK_SECRET`
- Se usa para validar que el webhook viene realmente de RevenueCat

### 4. Timing
- El estado premium puede tardar unos segundos en activarse
- La app realiza m√∫ltiples intentos (hasta 5) para verificar el estado
- El webhook puede llegar antes o despu√©s de que la app actualice el estado

---

## üîç DEBUGGING

### Verificar en la App:
- Logs de consola con prefijos:
  - `[PREMIUM SCREEN]`
  - `[PREMIUM CONTEXT]`
  - `[PURCHASE]`
  - `[REFRESH]`

### Verificar en RevenueCat:
- Dashboard ‚Üí Customers ‚Üí Buscar por App User ID
- Verificar que el entitlement est√© activo
- Verificar eventos de webhook (si est√°n disponibles)

### Verificar en Render:
- Logs del servidor con prefijos:
  - `[REVENUECAT]`
  - `[PURCHASE]`
  - `[AFFILIATE]`

### Problemas Comunes:

1. **Webhook no llega:**
   - Verificar URL del webhook en RevenueCat dashboard
   - Verificar que Render est√© corriendo y accesible
   - Verificar logs en Render

2. **Usuario no encontrado:**
   - Verificar que `app_user_id` en RevenueCat coincida con `id` en BD
   - Verificar logs en Render para ver qu√© `app_user_id` recibi√≥

3. **Comisi√≥n no se genera:**
   - Verificar que el usuario tenga c√≥digo de referencia en `user_referrals`
   - Verificar que el c√≥digo exista en `affiliate_codes`
   - Verificar logs de `AffiliateService`

---

## üìù NOTAS ADICIONALES

- El endpoint `/api/subscriptions/purchase` es **opcional** - la app lo intenta llamar pero si falla, el webhook se encargar√° de procesar la comisi√≥n
- El estado premium se verifica principalmente desde RevenueCat SDK, no desde el backend
- Las renovaciones autom√°ticas tambi√©n generan webhooks de tipo `RENEWAL`
- Las cancelaciones generan eventos de tipo `CANCELLATION`

